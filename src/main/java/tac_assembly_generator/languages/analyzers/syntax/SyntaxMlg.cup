//cup -parser "SyntaxMlgAnalyzer" -symbols "SimbolosMlg" "SyntaxMlg.cup"
package tac_assembly_generator.languages.analyzers.syntax;

import java_cup.runtime.Symbol;

import java.util.ArrayList;
import tac_assembly_generator.languages.semantic.verification.TestManager;
import tac_assembly_generator.TAC.TranslateControlerTAC;
import tac_assembly_generator.TAC.quadruple.Operation;
import tac_assembly_generator.TAC.quadruple.Quadruple;
import tac_assembly_generator.TAC.quadruple.BoolQuad;
import tac_assembly_generator.languages.semantic.type.Type;
import tac_assembly_generator.languages.semantic.type.TypeManager;
import tac_assembly_generator.TAC.asst.Switch;
import tac_assembly_generator.languages.semantic.UniquenessTable;
import tac_assembly_generator.TAC.asst.For;
import tac_assembly_generator.languages.semantic.SemanticAsstIdQuad;

 parser code {:
    

public boolean SyntaxError;
    public boolean SyntaxRecoverableError;
    public TestManager testManager;
    public TranslateControlerTAC translateControlerTAC;

    public void setTestManager(TestManager testManager) {
        this.testManager = testManager;
    }

public void setTranslateControlerTAC(TranslateControlerTAC translateControlerTAC) {
        this.translateControlerTAC = translateControlerTAC;
    }

     public void syntax_error(Symbol s){
        try {
            String lexema = s.value.toString();
            int fila = s.right;
            int columna = s.left;
            System.out.println("Error Sintactico Recuperado\n");
            System.out.println("\t \tLexema: " + lexema + "\n");
            System.out.println("\t \tFila: " + fila + "\n");
            System.out.println("\t \tColumna: " + columna + "\n");
        } catch (Exception e) {
            System.out.println("error");
            int fila = s.right;
            int columna = s.left;
            System.out.println("\t \tFila: " + fila + "\n");
            System.out.println("\t \tColumna: " + columna + "\n");
        }

    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        try{
            String lexema = s.value.toString();
            int fila = s.right;
            int columna = s.left;
        System.out.println("Error Sintactico Recuperado\n");
        System.out.println("\t \tLexema: "+ lexema+"\n");
        System.out.println("\t \tFila: "+ fila+"\n");
        System.out.println("\t \tColumna: "+ columna+"\n");

        } catch (Exception ex) {
            
         }
    }
:}

action code{:

:}


terminal VB_SEPERATOR, ERROR;

// Terminals Common Symbols & Keywords*/
terminal EQUAL, PARENTHESIS_A, PARENTHESIS_B, PLUS, MINUS, MULTIPLICATION, DIVISION, MOD, LINE_BREAK,
POINT, AMPERSON, COMMA, INTEGER_TYPE, FLOAT_TYPE, CHAR_TYPE, OR, AND, NOT,
INTINPUT, CHARINPUT, FLOATINPUT, PUBLIC, FOR, WHILE, DO,
TRUE, FALSE, IF, ELSE, GREATER_THAN,
LESS_THAN, GREATER_THAN_EQUAL, LESS_THAN_EQUAL, EQUAL_BOOL;

terminal String STRING, ID, CHAR;

terminal String NUMBER;
terminal String DECIMAL;

// Terminals Visual Basic */
terminal JAVA_SEPERATOR, DIM_VB, AS_VB,
FUNCTION_VB, END_VB, SUB_VB,RETURN_VB, CONSOLE_VB, WRITE_VB,
WRITELN_VB, TO_VB, STEP_VB, NEXT_VB,
DIFERENT_VB, LOOP_VB,
ELSE_IF_VB, THEN_VB, SELECT_VB, CASE_VB ;


// Terminals Java */
terminal PYTHON_SEPERATOR, CLASS_J, VOID_J, RETURN_J, SYSTEM_OUT_PRINTLN,
SYSTEM_OUT_PRINT, SWITCH_J, CASE_J, DEFAULT_J, BREAK, SEMICOLON,
LEFT_CB, RIGHT_CB, COLON, DIFERENT_J;

// Terminals Python*/
terminal PROGRAM_SEPERATOR,NODENT, DEDENT, INDENT ;

// Terminals C*/
terminal CONST, LEFT_BRACKET, RIGHT_BRACKET, INCLUDE,
PRINTF, CLRSCR, GETCH, SCAN_F, MAIN ;

    
//Non-terminals Common or StartUp*/
non terminal Inicio, VB, Java, Python,
VbCode, JavaCode, PythonCode, Programa,VbSeperator,
OpLogic, Type, Public;

//Non-terminals VB*/
non terminal FunctionVB, FunctionVbHeader, SubVb, SubVbHeader, Parameters, Parameter, InstructionsFunctionVb, InstructionsFunctionVb2, LnInstructionsVb, Lines,
InputVb, OutputVb, ValuesVb, ValueVb, CycleVb, ForVb, ForVbHeader, ForVbHeaderStart, For, Step, NumberValue,
Number2, Number3, WhileVb, WhileVbHeader, OpBool, OpBool2, OpBool3, BoolValueVb, ExBoolVb, DoWhileVb, DoHeader, DeclarationVb,
DeTypeVb, IdsVb, AssiVb, AssignmentVb, ConditionVb, IfVb, IfVbHeader, ElseVb, ElseHeader, ElseIfHeader,  ThenVb, SwitchVb, SwitchVbHeader,
CasesVb, CasesVbHeader, CaseValue;

//Non-terminals JAVA*/
non terminal ClaseJ, ClaseJHeader,ConditionJHeader, ParametersJ, JavaClassCode, ClassCodeJ,
FunctionJ, FunctionJHeader, ProcessJ, ProcessJHeader, LineCodesJ, LineCodesJ2, ValuesJ, StringValue,
ValuesOutputJ, ValJ, LineCodeJ, OutputJ, InputJ,
CycleJ, ForJHeader, WhileJHeader, StepJ, DeclarationJ, AssignmentJ, ConditionJ, IfJ,
IfJHeader, ElseJ, SwitchJHeader, CasesJ1, CasesJ2, CaseJ, BreakJ,
ExBoolJ, BoolValueJ, OpBoolJ, ConstructorJ; 


// non Terminals MAIN
non terminal Library, Main, Constantes, Constante, Dimensions, ArrayValues,
Nums, Rows, Globals, Include, MainCode, MainLineCode, DeclarationC,IdsC,
AssiC, AssignmentC, ConditionC, IfCHeader, SwitchCHeader, CasesC, CasesC2,
CaseC, CycleC, ForCHeader, WhileCHeader, StepC, OutputC, OutputValuesC, OutputValueC,
Getch, Input, FuntionCall, FuntionIDs, ParametersC, ValueC, BoolValueC,
OpBoolC, ArrayVal;

start with Inicio;
Inicio 		::= VB Java Python  Programa {:System.out.println("FIN Inicio");
                                        sma.translateControlerTAC.printQuads();
                                        :};
                
/*
    VB
*/
VB 			::= VbSeperator  VbCode {:sma.testManager.switchNextTypes();
                                    sma.translateControlerTAC.acceptCurrentBlock();
                                    :};
                
VbSeperator::= VB_SEPERATOR{:sma.translateControlerTAC.createNewQuadrupleBlock();:};

VbCode     ::= FunctionVB VbCode  
                | SubVb VbCode
		        |
                |error VbCode; 
 
FunctionVB	::= FunctionVbHeader InstructionsFunctionVb:ins END_VB FUNCTION_VB {:sma.translateControlerTAC.convertQuads((ArrayList<Object>)ins);:};
FunctionVbHeader::= Public FUNCTION_VB ID PARENTHESIS_A Parameters PARENTHESIS_B AS_VB Type {:sma.testManager.creatFatherAmbit();
                                                                                            sma.translateControlerTAC.createNewQuadrupleBlock();
                                                                                            sma.testManager.insertParameters();:};
                    
SubVb      ::=  SubVbHeader InstructionsFunctionVb END_VB SUB_VB {:sma.testManager.finishAmbit();
                                                                            sma.translateControlerTAC.acceptCurrentBlock();:}; 
SubVbHeader::= Public SUB_VB ID PARENTHESIS_A Parameters PARENTHESIS_B{:sma.testManager.creatFatherAmbit();
                                                                                            sma.translateControlerTAC.createNewQuadrupleBlock();
                                                                                            sma.testManager.insertParameters();:};
Public::= PUBLIC
            |;
Parameters::= Parameter 
            |;
Parameter   ::= Parameter COMMA ID:id AS_VB Type:type {:sma.testManager.getParameterControl().insertParameter((Integer)type,id,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));:}
                | ID:id AS_VB Type:type {:sma.testManager.getParameterControl().insertParameter((Integer)type,id,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));:} ;
InstructionsFunctionVb  ::=InstructionsFunctionVb2{: RESULT=sma.translateControlerTAC.getcurrentQuads();
                                                    sma.testManager.finishAmbit();
                                                    sma.translateControlerTAC.acceptCurrentBlock();
                                                    :};
InstructionsFunctionVb2::= Lines LnInstructionsVb  
                            |Lines RETURN_VB ValuesVb
                            |Lines RETURN_VB
                            |LnInstructionsVb 
                            |RETURN_VB ValuesVb
                            |RETURN_VB;
Lines               ::=Lines LnInstructionsVb
                        |LnInstructionsVb;
LnInstructionsVb::= InputVb     
				|OutputVb 
				|CycleVb 
				|DeclarationVb  {:System.out.println("DECLARACION");:}
				|AssignmentVb   {:System.out.println("ASIGNACION");:}
                |ConditionVb  
				|error;
InputVb			::= INTINPUT PARENTHESIS_A STRING PARENTHESIS_B
					|FLOATINPUT PARENTHESIS_A STRING PARENTHESIS_B
					| CHARINPUT PARENTHESIS_A STRING PARENTHESIS_B ;
	
OutputVb		::=CONSOLE_VB POINT WRITE_VB PARENTHESIS_A ValuesVb:vals PARENTHESIS_B{: if(vals!=null){
                                                                                                sma.translateControlerTAC.addQuadsToCurrent((ArrayList<Object>)vals);
                                                                                                
                                                                                            }:}
					|CONSOLE_VB POINT WRITELN_VB PARENTHESIS_A ValuesVb:vals PARENTHESIS_B{:Quadruple lineBreak = sma.translateControlerTAC.createPrintQuad("\n");
                                                                                            if(vals!=null){
                                                                                                ArrayList asst=(ArrayList<Object>)vals;
                                                                                                asst.add(lineBreak);
                                                                                                sma.translateControlerTAC.addQuadsToCurrent(asst);
                                                                                                
                                                                                                
                                                                                            }:};
ValuesVb			::= ValuesVb:vals AMPERSON ValueVb:val{:ArrayList<Object> printQuad= new ArrayList<Object>();
                                    printQuad.addAll((ArrayList<Object>)vals);
                                    printQuad.addAll((ArrayList<Object>)val);
                                    RESULT=printQuad;:}
				|ValueVb:val {:ArrayList<Object> printQuad= new ArrayList<Object>();
                                    printQuad.addAll((ArrayList<Object>)val);
                                    RESULT=printQuad;:};
ValueVb			::=STRING:string {:ArrayList<Object> printQuad= new ArrayList<Object>();
                                    printQuad.add(sma.translateControlerTAC.createPrintQuad(string));
                                    RESULT=printQuad;:}
				|NumberValue:val{:ArrayList<Object> printQuad= new ArrayList<Object>();
                                    printQuad.addALL(sma.translateControlerTAC.getcurrentTempQuads());
                                    printQuad.add(sma.translateControlerTAC.createPrintQuad(val));
                                    RESULT=printQuad;:};

CycleVb         ::= ForVb
                    |WhileVb
                    |DoWhileVb;

ForVb           ::=  ForVbHeader:f InstructionsFunctionVb:lines NEXT_VB {:if(f!=null){
                                                                For fo=(For)f;
                                                                fo.addCode((ArrayList<Object>)lines);
                                                                sma.translateControlerTAC.addQuadsToCurrent(fo.convertToQuad());
                                                                }:};
                
ForVbHeader           ::= ForVbHeaderStart:id TO_VB NumberValue:num Step:step {:if (id!=null) {
                    SemanticAsstIdQuad saiq= (SemanticAsstIdQuad)id;
                    SynthesizedOpAsst s1= (SynthesizedOpAsst)num;
                    Quadruple quadruple=sma.translateControlerTAC.operateIdBoolQuadruple(saiq.getId(),s1.getQuadruple(),Operation.EQUAL_BOOL);
                    BoolQuad bool =sma.translateControlerTAC.getBoolQuadControl().convertQuadToBool(sma.translateControlerTAC.getcurrentTempQuads());
                     For f=sma.translateControlerTAC.createForAsst(saiq.getQuads(), (String) step, bool, saiq.getId());
                    RESULT=f;}:};
ForVbHeaderStart        ::=For ID:id AS_VB Type EQUAL NumberValue:val {:boolean bool= sma.testManager.assigValue(id,val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                if(bool){sma.translateControlerTAC.creatTempIdQuadAssign(val,id);
                                                        sma.translateControlerTAC.acceptAllIdQuas();
                                                        RESULT=id;}:}
                    |For ID:id EQUAL NumberValue:val{:Type type=sma.testManager.getTypeFromST(id,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                    if(type!=null){
                                                    if(sma.testManager.getTypeManager().isNumerico(type.getNumber())){
                                                        
                                                        boolean bool= sma.testManager.assigValue(id,val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                        if(bool){sma.translateControlerTAC.creatTempIdQuadAssign(val,id);
                                                            RESULT=new SemanticAsstIdQuad(id, sma.translateControlerTAC.getcurrentTempQuads());
                                                        }
                                                    }else{
                                                        sma.testManager.callNumericError(id,type,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                    }}:};
For::= FOR{:sma.testManager.creatSonAmbit();
                                                        sma.translateControlerTAC.createNewQuadrupleBlock();:};
Step            ::= STEP_VB CaseValue:value {:RESULT=value;:}
                    | STEP_VB MINUS CaseValue:value{:RESULT="-"+(String)value;:}
                    | STEP_VB PLUS CaseValue:value{:RESULT=value;:}
                    |{:RESULT="1";:};
//NextVb          ::= NEXT_VB ID
  //                  | NEXT_VB;
                    
NumberValue::= NumberValue:num1 PLUS  Number2:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.PLUS);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                |NumberValue:num1 MINUS  Number2:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MINUS);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                |Number2:asst {:RESULT=asst;:};  
Number2     ::=Number2:num1 MULTIPLICATION  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MULTIPLICATION);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number2:num1 DIVISION  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.DIVISION);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number2:num1 MOD  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MOD);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number3:asst {:RESULT=asst;:};
Number3     ::=NUMBER:val{: Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.INTEGER_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}

                |DECIMAL:val{:Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.FLOAT_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}
                |CHAR :val{:Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.CHAR_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}
                |ID:val {:Type type=sma.testManager.getTypeFromST(val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                            if(type!=null){
                                Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
                                RESULT=new SynthesizedOpAsst(quadruple,type);
                            }else{

                                RESULT=null;
                            }:}
                |PARENTHESIS_A NumberValue:asst PARENTHESIS_B {:RESULT=asst;:};
        
         

WhileVb         ::= WhileVbHeader:whileBool InstructionsFunctionVb:lines END_VB WHILE{:BoolQuad bool=(BoolQuad)whileBool;
                                                                                    if(lines!=null){bool.changeFatherYesBool((ArrayList<Object>)lines);}
                                                                                    sma.translateControlerTAC.addQuadsToCurrent(sma.translateControlerTAC.addGotoWhileTags(sma.translateControlerTAC.getBoolQuadControl().convertBoolToQuad(bool)));
                                                                                    :};
WhileVbHeader   ::= WHILE  OpBool:op{:sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();
                                        RESULT=op;:};

OpBool::= OpBool:val1 OR OpBool2:val2 {:if(val1!=null &&val2!=null){
                                            RESULT= sma.translateControlerTAC.getBoolQuadControl().operateBoolQuad(val1,val2,Operation.OP_OR);}
                                            :}

       |OpBool2 :val{:RESULT=val;:};
OpBool2::= OpBool2:val1 AND OpBool3:val2 {:if(val1!=null &&val2!=null){
                                            RESULT= sma.translateControlerTAC.getBoolQuadControl().operateBoolQuad(val1,val2,Operation.OP_AND);}
                                            :}
        |OpBool3:val{:RESULT=val;:};
OpBool3::=NOT  BoolValueVb
        |BoolValueVb:val {:if(val!=null){
                   RESULT = sma.translateControlerTAC.getBoolQuadControl().convertQuadToBool(((ArrayList<Object>)val)); 
        }:};
BoolValueVb       ::=TRUE {: Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.BOOL_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL_BOOL,1,1,null);
		                    RESULT=sma.translateControlerTAC.getcurrentTempQuads();:}
                    |FALSE {: Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.BOOL_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL_BOOL,0,1,null);
		                    RESULT=sma.translateControlerTAC.getcurrentTempQuads();:}
                    |NumberValue:num1 ExBoolVb:exVal Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateBoolType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdBoolQuadruple(s1.getQuadruple(),s2.getQuadruple(),(Integer)exVal);
                                                                    RESULT=sma.translateControlerTAC.getcurrentTempQuads();
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                    | PARENTHESIS_A OpBool:val PARENTHESIS_B {:RESULT=val;:};

ExBoolVb          ::=EQUAL{:RESULT=Operation.EQUAL_BOOL;:}
                    |DIFERENT_VB {:RESULT=Operation.DIFERENT;:}
                    |GREATER_THAN {:RESULT=Operation.GREATER_THAN;:}
                    |LESS_THAN {:RESULT=Operation.LESS_THAN;:}
                    |GREATER_THAN_EQUAL {:RESULT=Operation.GREATER_THAN_EQUAL;:}
                    |LESS_THAN_EQUAL {:RESULT=Operation.LESS_THAN_EQUAL;:};

DoWhileVb       ::= DoHeader  InstructionsFunctionVb:lines LOOP_VB WHILE OpBool:op {:if(op!=null){
                                                                                sma.translateControlerTAC.addQuadsToCurrent(sma.translateControlerTAC.creatDoWhile((ArrayList<Object>)lines,(BoolQuad)op));
                                                                                }:};

DoHeader        ::= DO{:sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();:};

DeclarationVb     ::= DIM_VB DeTypeVb:val {:RESULT=val;:};
DeTypeVb        ::=  DeTypeVb COMMA  IdsVb AS_VB Type:type AssiVb {:sma.testManager.insertPreTuplesToSymbolTable((Integer)type,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()),sma.translateControlerTAC);:}
                    |IdsVb AS_VB Type:type AssiVb {:sma.testManager.insertPreTuplesToSymbolTable((Integer)type,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()),sma.translateControlerTAC);:};
Type          ::=INTEGER_TYPE{:RESULT=TypeManager.INTEGER_TYPE;:}
                    |FLOAT_TYPE {:RESULT=TypeManager.FLOAT_TYPE;:}
                    |CHAR_TYPE{:RESULT=TypeManager.CHAR_TYPE;:};                   

IdsVb           ::= IdsVb COMMA  ID:id AssiVb:val{:sma.testManager.insertPreTuple(id,null,val,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                        if(val!=null){ 
                                                            sma.translateControlerTAC.creatTempIdQuadAssign(val,id);}
                                                       
                                                        sma.translateControlerTAC.nextIdQuad();:}  
                    |ID:id AssiVb:val{:sma.testManager.insertPreTuple(id,null,val,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                        if(val!=null){ 
                                                            sma.translateControlerTAC.creatTempIdQuadAssign(val,id);}
                                        sma.translateControlerTAC.nextIdQuad();:}; 

AssiVb            ::= EQUAL NumberValue:val {:RESULT = val;:}
                    |{:System.out.println("ASSI VACIO");:};

AssignmentVb      ::=ID:id EQUAL NumberValue:val {:boolean bool= sma.testManager.assigValue(id,val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                if(bool){sma.translateControlerTAC.creatTempIdQuadAssign(val,id);
                                                        sma.translateControlerTAC.acceptAllIdQuas();}:};

ConditionVb        ::= IfVb
                    |SwitchVb;

IfVb            ::= IfVbHeader:ifBool InstructionsFunctionVb:lines ElseVb:elseBool END_VB IF {:BoolQuad bool=(BoolQuad)ifBool;
                                                                                    if(lines!=null){bool.changeFatherYesBool((ArrayList<Object>)lines);}
                                                                                    if(elseBool!=null){bool.changeFatherNoBool((ArrayList<Object>)elseBool);}
                                                                                    sma.translateControlerTAC.addQuadsToCurrent(sma.translateControlerTAC.getBoolQuadControl().convertBoolToQuad(bool));
                                                                                    :};
IfVbHeader      ::=IF OpBool:op ThenVb {:sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();
                                        RESULT=op;:};
ElseVb          ::= ElseHeader  InstructionsFunctionVb:lines{:RESULT=lines;:}


                    |ElseIfHeader:ifBool InstructionsFunctionVb:lines ElseVb:elseBool{:if(ifBool!=null){
                                                                    BoolQuad bool=(BoolQuad)ifBool;
                                                                                    if(lines!=null){bool.changeFatherYesBool((ArrayList<Object>)lines);}
                                                                                    if(elseBool!=null){bool.changeFatherNoBool((ArrayList<Object>)elseBool);}
                                                                                    RESULT =sma.translateControlerTAC.getBoolQuadControl().convertBoolToQuad(bool);
                                                                                    
                                                                }:}
                    |; 
ElseHeader      ::= ELSE{:sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();:};
ElseIfHeader    ::= ELSE_IF_VB OpBool:op ThenVb{:sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();
                                        RESULT =op;:};

ThenVb          ::= THEN_VB
                    |;
SwitchVb        ::= SwitchVbHeader CasesVb END_VB SELECT_VB{:sma.translateControlerTAC.addQuadsToCurrent(sma.translateControlerTAC.getBoolQuadControl().convertBoolToQuad(sma.translateControlerTAC.getSwitchAsst().getFatherCases()));:};
SwitchVbHeader  ::= SELECT_VB CASE_VB ID:id {:sma.translateControlerTAC.createSwitchAsst(id);:};
CasesVb         ::= CasesVb:caseVb CasesVbHeader:caseH InstructionsFunctionVb:lines{:UniquenessTable ut=(UniquenessTable)caseVb;
                                                                        if(caseH!=null){
                                                                            
                                                                            boolean verified =ut.add(caseH,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                            if(verified){
                                                                            
                                                                            sma.translateControlerTAC.getSwitchAsst().addCases((String)caseH,(ArrayList<Object>)lines);}
                                                                            }
                                                                        RESULT=ut;:} 
                    |CasesVbHeader:caseH InstructionsFunctionVb:lines{:UniquenessTable ut=sma.testManager.createNewUniquenessTable();
                                                                        if(caseH!=null){
                                                                            
                                                                            boolean verified =ut.add(caseH,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                            if(verified){
                                                                            
                                                                            sma.translateControlerTAC.getSwitchAsst().addCases((String)caseH,(ArrayList<Object>)lines);}
                                                                            }
                                                                        RESULT=ut;:};
                                                                            
CasesVbHeader   ::= CASE_VB CaseValue:val{:RESULT=val;
                                            sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();:}

                    |CASE_VB ELSE{:RESULT=Switch.ELSE;
                    sma.testManager.creatSonAmbit();
                                        sma.translateControlerTAC.createNewQuadrupleBlock();:};
CaseValue       ::=NUMBER:num {:RESULT=num;:}
                    |DECIMAL:dec {:RESULT=dec;:}
                    |CHAR:ch  {:RESULT=ch;:}
                    |ID:id {:Type type=sma.testManager.getTypeFromST(id,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                            if(type!=null){
                                RESULT=id;
                            }:};

/*
    JAVA
*/
Java 			::= JAVA_SEPERATOR JavaCode {:sma.testManager.switchNextTypes();:};

JavaCode::=JavaCode ClaseJ
            |;
ClaseJ  ::= ClaseJHeader LEFT_CB JavaClassCode RIGHT_CB;
ClaseJHeader::= PUBLIC CLASS_J ID {:sma.testManager.creatFatherAmbit();:};
ParametersJ::=ParametersJ COMMA Type ID
                | Type ID;
JavaClassCode::=JavaClassCode ClassCodeJ
                |ClassCodeJ;
ClassCodeJ  ::=FunctionJ
                |ProcessJ
                |LineCodeJ
                |ConstructorJ;
ConstructorJ ::=ConditionJHeader LEFT_CB LineCodesJ RIGHT_CB;
ConditionJHeader::=PUBLIC ID PARENTHESIS_A ParametersJ PARENTHESIS_B ;
FunctionJ       ::= FunctionJHeader  LEFT_CB LineCodesJ RIGHT_CB 
                    |FunctionJHeader  LEFT_CB  RIGHT_CB;
FunctionJHeader ::= PUBLIC Type ID PARENTHESIS_A ParametersJ PARENTHESIS_B
                    |PUBLIC Type ID PARENTHESIS_A PARENTHESIS_B;
ProcessJ        ::= ProcessJHeader LEFT_CB LineCodesJ RIGHT_CB
                    |ProcessJHeader LEFT_CB  RIGHT_CB;                 
ProcessJHeader  ::= PUBLIC VOID_J ID PARENTHESIS_A ParametersJ PARENTHESIS_B
                |PUBLIC VOID_J ID PARENTHESIS_A  PARENTHESIS_B;
LineCodesJ      ::=LineCodesJ2 RETURN_J ValuesJ
                    | LineCodesJ2;
LineCodesJ2      ::= LineCodesJ2 LineCodeJ
                |LineCodeJ;
ValuesJ         ::=StringValue
				|NumberValue;
StringValue     ::= StringValue PLUS STRING
                    |STRING;

ValuesOutputJ   ::=ValuesOutputJ PLUS ValJ
                    |ValJ;
                    
ValJ::=ID
                    |NUMBER
                    |DECIMAL
                    |STRING;

LineCodeJ   ::=OutputJ SEMICOLON
                |InputJ SEMICOLON
                |CycleJ
                |DeclarationJ SEMICOLON  {:System.out.println("DECLARACION");:}
				|AssignmentJ SEMICOLON  {:System.out.println("ASIGNACION");:}
                |ConditionJ 
                |error;
OutputJ     ::=SYSTEM_OUT_PRINTLN PARENTHESIS_A ValuesOutputJ PARENTHESIS_B
                |SYSTEM_OUT_PRINT PARENTHESIS_A ValuesOutputJ PARENTHESIS_B;

InputJ      ::= INTINPUT PARENTHESIS_A STRING PARENTHESIS_B
					|FLOATINPUT PARENTHESIS_A STRING PARENTHESIS_B
					| CHARINPUT PARENTHESIS_A STRING PARENTHESIS_B ;
CycleJ      ::=ForJHeader LEFT_CB LineCodesJ RIGHT_CB
                |WhileJHeader LEFT_CB LineCodesJ RIGHT_CB
                |DO LEFT_CB LineCodesJ RIGHT_CB WhileJHeader SEMICOLON;
ForJHeader        ::= FOR PARENTHESIS_A Type ID EQUAL NumberValue SEMICOLON ID ExBoolJ NumberValue SEMICOLON StepJ PARENTHESIS_B 
                    |FOR PARENTHESIS_A ID EQUAL NumberValue SEMICOLON ID ExBoolJ NumberValue SEMICOLON StepJ PARENTHESIS_B ;
WhileJHeader        ::= WHILE PARENTHESIS_A OpBoolJ PARENTHESIS_B; 
StepJ           ::= ID EQUAL NumberValue
                    |ID PLUS EQUAL NumberValue
                    |ID MINUS EQUAL NumberValue
                    |ID MULTIPLICATION EQUAL NumberValue
                    |ID DIVISION EQUAL NumberValue;   
DeclarationJ    ::=PUBLIC Type IdsVb{::}
                    |Type IdsVb{::};
AssignmentJ     ::= ID EQUAL NumberValue;

ConditionJ      ::= IfJ 
                    |SwitchJHeader LEFT_CB CasesJ1 RIGHT_CB;
IfJ             ::= IfJHeader LEFT_CB LineCodesJ RIGHT_CB ElseJ;
IfJHeader       ::= IF PARENTHESIS_A OpBoolJ PARENTHESIS_B;
ElseJ           ::= ELSE LEFT_CB LineCodesJ RIGHT_CB 
                    | ELSE IfJ
                    |;
SwitchJHeader   ::= SWITCH_J PARENTHESIS_A ID PARENTHESIS_B;
CasesJ1          ::=CasesJ2 CaseJ
                |CasesJ2 DEFAULT_J COLON LineCodesJ BreakJ
                |CaseJ;
CasesJ2         ::= CasesJ2 CaseJ
                    | CaseJ;
CaseJ           ::= CASE_J ValuesJ COLON LineCodesJ BreakJ;
BreakJ         ::= BREAK SEMICOLON
                    |;

ExBoolJ         ::=EQUAL_BOOL 
                    |DIFERENT_J
                    |GREATER_THAN
                    |LESS_THAN                    
                    |GREATER_THAN_EQUAL
                    |LESS_THAN_EQUAL;
BoolValueJ       ::=NOT BoolValueJ
                    |PARENTHESIS_A OpBoolJ PARENTHESIS_B
                    //|ID 
                    |TRUE
                    |FALSE
                    |NumberValue ExBoolJ NumberValue;
OpBoolJ::= OpBoolJ OpLogic BoolValueJ
        |BoolValueJ;
/*
    Python
*/
Python 	::= PYTHON_SEPERATOR PythonCode {:sma.testManager.switchNextTypes();:};
PythonCode::=;
/*
    C
*/

Programa ::=PROGRAM_SEPERATOR Library Constantes Globals Main ;
Library::= Library Include 
            | ;
Constantes ::= Constantes  Constante SEMICOLON
                |Constante SEMICOLON;
Constante::=CONST Type ID EQUAL ValueC
            |CONST Type ID Dimensions EQUAL ArrayValues;
Dimensions ::= Dimensions LEFT_BRACKET NumberValue RIGHT_BRACKET
                |LEFT_BRACKET NumberValue RIGHT_BRACKET;
ArrayValues ::= LEFT_CB Nums RIGHT_CB
                | LEFT_CB Rows RIGHT_CB;
Nums        ::= Nums COMMA NumberValue
                |NumberValue;
Rows        ::= Rows COMMA LEFT_CB Nums RIGHT_BRACKET
                |LEFT_CB Nums RIGHT_BRACKET;

Globals     ::=Globals  DeclarationC SEMICOLON
                |DeclarationC SEMICOLON;
Include ::= INCLUDE STRING 
            |INCLUDE LESS_THAN FuntionIDs GREATER_THAN;
Main::= VOID_J MAIN PARENTHESIS_A  PARENTHESIS_B LEFT_CB MainCode RIGHT_CB;

MainCode::= MainCode MainLineCode
            |MainLineCode;
MainLineCode ::= DeclarationC SEMICOLON
                |AssignmentC SEMICOLON
                |ConditionC
                |CycleC
                |OutputC SEMICOLON
                |Getch SEMICOLON
                |Input SEMICOLON
                |FuntionCall SEMICOLON;
DeclarationC  ::= Type IdsC;
IdsC           ::=ID AssiC COMMA IdsVb  
                    |ID AssiC; 
AssiC            ::= EQUAL ValueC
                    |Dimensions
                    |Dimensions EQUAL ArrayValues
                    |{:System.out.println("ASSI VACIO");:};

AssignmentC::= ID EQUAL ValueC
                |ID Dimensions EQUAL ValueC;
ConditionC  ::= IfCHeader LEFT_CB MainCode RIGHT_CB
                |SwitchCHeader  LEFT_CB CasesC RIGHT_CB;
IfCHeader::= IF PARENTHESIS_A OpBoolC PARENTHESIS_B;

SwitchCHeader::=SWITCH_J PARENTHESIS_A ID PARENTHESIS_B;
CasesC       ::=CasesC2 CaseC
                |CasesC2 DEFAULT_J COLON MainCode BreakJ
                |CaseC;
CasesC2     ::= CasesC2 CaseC
                |CaseC;
CaseC       ::= CASE_J COLON MainCode BreakJ;
CycleC      ::=ForCHeader LEFT_CB MainCode RIGHT_CB
                |WhileCHeader LEFT_CB MainCode RIGHT_CB
                |DO LEFT_CB MainCode RIGHT_CB WhileCHeader SEMICOLON;
ForCHeader        ::= FOR PARENTHESIS_A Type ID EQUAL ValueC SEMICOLON OpBoolC SEMICOLON StepC PARENTHESIS_B 
                    |FOR PARENTHESIS_A ID EQUAL ValueC SEMICOLON OpBoolC SEMICOLON StepC PARENTHESIS_B ;
WhileCHeader        ::= WHILE PARENTHESIS_A OpBoolC PARENTHESIS_B; 
StepC          ::= ID EQUAL ValueC
                    |ID PLUS EQUAL ValueC
                    |ID MINUS EQUAL ValueC
                    |ID MULTIPLICATION EQUAL ValueC
                    |ID DIVISION EQUAL ValueC;
OutputC         ::= PRINTF PARENTHESIS_A  OutputValuesC PARENTHESIS_B
                    |CLRSCR PARENTHESIS_A PARENTHESIS_B;
OutputValuesC   ::= OutputValuesC COMMA OutputValueC
                    |OutputValueC;
OutputValueC    ::= NUMBER
                    |ID
                    |DECIMAL
                    |STRING;

Getch ::=GETCH PARENTHESIS_A PARENTHESIS_B;
Input   ::= SCAN_F PARENTHESIS_A STRING COMMA AMPERSON ID PARENTHESIS_B ;
FuntionCall::=FuntionIDs PARENTHESIS_A ParametersC PARENTHESIS_B
                |FuntionIDs PARENTHESIS_A  PARENTHESIS_B;
FuntionIDs::= FuntionIDs POINT ID
            |ID;
ParametersC::=ParametersC COMMA ValueC 
            |ValueC;
ValueC::=STRING
        |NumberValue
        |FuntionCall
        |Getch
        |ArrayVal;

ArrayVal::= ID Dimensions;
BoolValueC       ::=NOT BoolValueC
                    |PARENTHESIS_A OpBoolJ PARENTHESIS_B
                    //|ID 
                    |FuntionCall
                    |TRUE
                    |FALSE
                    |NumberValue ExBoolJ NumberValue;
OpBoolC::= OpBoolC OpLogic BoolValueC
        |BoolValueC;




//cup -parser "SyntaxMlgAnalyzer" -symbols "SimbolosMlg" "SyntaxMlg.cup"
package tac_assembly_generator.languages.analyzers.syntax;

import java_cup.runtime.Symbol;

import java.util.ArrayList;
import tac_assembly_generator.languages.semantic.verification.TestManager;
import tac_assembly_generator.TAC.TranslateControlerTAC;
import tac_assembly_generator.TAC.quadruple.Operation;
import tac_assembly_generator.TAC.quadruple.Quadruple;
import tac_assembly_generator.languages.semantic.type.Type;
import tac_assembly_generator.languages.semantic.type.TypeManager;
 parser code {:
    

public boolean SyntaxError;
    public boolean SyntaxRecoverableError;
    public TestManager testManager;
    public TranslateControlerTAC translateControlerTAC;

    public void setTestManager(TestManager testManager) {
        this.testManager = testManager;
    }

public void setTranslateControlerTAC(TranslateControlerTAC translateControlerTAC) {
        this.translateControlerTAC = translateControlerTAC;
    }

     public void syntax_error(Symbol s){
        try {
            String lexema = s.value.toString();
            int fila = s.right;
            int columna = s.left;
            System.out.println("Error Sintactico Recuperado\n");
            System.out.println("\t \tLexema: " + lexema + "\n");
            System.out.println("\t \tFila: " + fila + "\n");
            System.out.println("\t \tColumna: " + columna + "\n");
        } catch (Exception e) {
            System.out.println("error");
            int fila = s.right;
            int columna = s.left;
            System.out.println("\t \tFila: " + fila + "\n");
            System.out.println("\t \tColumna: " + columna + "\n");
        }

    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        try{
            String lexema = s.value.toString();
            int fila = s.right;
            int columna = s.left;
        System.out.println("Error Sintactico Recuperado\n");
        System.out.println("\t \tLexema: "+ lexema+"\n");
        System.out.println("\t \tFila: "+ fila+"\n");
        System.out.println("\t \tColumna: "+ columna+"\n");

        } catch (Exception ex) {
            
         }
    }
:}

action code{:

:}


terminal VB_SEPERATOR, ERROR;

// Terminals Common Symbols & Keywords*/
terminal EQUAL, PARENTHESIS_A, PARENTHESIS_B, PLUS, MINUS, MULTIPLICATION, DIVISION, MOD, LINE_BREAK,
POINT, AMPERSON, COMMA, INTEGER_TYPE, FLOAT_TYPE, CHAR_TYPE, OR, AND, NOT,
INTINPUT, CHARINPUT, FLOATINPUT, PUBLIC, FOR, WHILE, DO,
TRUE, FALSE, IF, ELSE, GREATER_THAN,
LESS_THAN, GREATER_THAN_EQUAL, LESS_THAN_EQUAL;

terminal String STRING, ID, CHAR;

terminal String NUMBER;
terminal String DECIMAL;

// Terminals Visual Basic */
terminal JAVA_SEPERATOR, DIM_VB, AS_VB,
FUNCTION_VB, END_VB, SUB_VB,RETURN_VB, CONSOLE_VB, WRITE_VB,
WRITELN_VB, TO_VB, STEP_VB, NEXT_VB,
DIFERENT_VB, LOOP_VB,
ELSE_IF_VB, THEN_VB, SELECT_VB, CASE_VB ;


// Terminals Java */
terminal PYTHON_SEPERATOR, CLASS_J, VOID_J, RETURN_J, SYSTEM_OUT_PRINTLN,
SYSTEM_OUT_PRINT, SWITCH_J, CASE_J, DEFAULT_J, BREAK, SEMICOLON,
LEFT_CB, RIGHT_CB, COLON, DIFERENT_J;

// Terminals Python*/
terminal PROGRAM_SEPERATOR;

// Terminals C*/
terminal CONST, LEFT_BRACKET, RIGHT_BRACKET, INCLUDE,
PRINTF, CLRSCR, GETCH, SCAN_F, MAIN ;

    
//Non-terminals Common or StartUp*/
non terminal Inicio, VB, Java, Python,
VbCode, JavaCode, PythonCode, Programa,VbSeperator,
OpLogic, Type;

//Non-terminals VB*/
non terminal FunctionVB, FunctionVbHeader, Sub_VB, Parameters, Parameter, InstructionsFunctionVb, LnInstructionsVb, Lines,
InputVb, OutputVb, ValuesVb, ValueVb, CycleVb, ForVb, Step, NumberValue,
Number2, Number3, WhileVb, OpBool, BoolValueVb, ExBoolVb, DoWhileVb, DeclarationVb,
DeTypeVb, IdsVb, AssiVb, AssignmentVb, ConditionVb, IfVb, ElseVb, ThenVb, SwitchVb,
CasesVb;

//Non-terminals JAVA*/
non terminal ClaseJ, ClaseJHeader,ConditionJHeader, ParametersJ, JavaClassCode, ClassCodeJ,
FunctionJ, FunctionJHeader, ProcessJ, ProcessJHeader, LineCodesJ, LineCodesJ2, ValuesJ, StringValue,
ValuesOutputJ, ValJ, LineCodeJ, OutputJ, InputJ,
CycleJ, ForJHeader, WhileJHeader, StepJ, DeclarationJ, AssignmentJ, ConditionJ, IfJ,
IfJHeader, ElseJ, SwitchJHeader, CasesJ1, CasesJ2, CaseJ, BreakJ,
ExBoolJ, BoolValueJ, OpBoolJ, ConstructorJ; 


// non Terminals MAIN
non terminal Library, Main, Constantes, Constante, Dimensions, ArrayValues,
Nums, Rows, Globals, Include, MainCode, MainLineCode, DeclarationC,IdsC,
AssiC, AssignmentC, ConditionC, IfCHeader, SwitchCHeader, CasesC, CasesC2,
CaseC, CycleC, ForCHeader, WhileCHeader, StepC, OutputC, OutputValuesC, OutputValueC,
Getch, Input, FuntionCall, FuntionIDs, ParametersC, ValueC, BoolValueC,
OpBoolC, ArrayVal;

start with Inicio;
Inicio 		::= VB Java Python  Programa {:System.out.println("FIN Inicio");
                                        sma.translateControlerTAC.printQuads();
                                        sma.translateControlerTAC.convertQuads();:};
                
/*
    VB
*/
VB 			::= VbSeperator  VbCode {:sma.testManager.switchNextTypes();
                                    sma.translateControlerTAC.acceptCurrentBlock();:};
                
VbSeperator::= VB_SEPERATOR{:sma.translateControlerTAC.createNewQuadrupleBlock();:};

VbCode     ::= FunctionVB VbCode  
                | Sub_VB VbCode
		        |
                |error VbCode; 
 
FunctionVB	::= FunctionVbHeader InstructionsFunctionVb END_VB FUNCTION_VB {:sma.testManager.finishAmbit();
                                                                            sma.translateControlerTAC.acceptCurrentBlock();:};
FunctionVbHeader::= PUBLIC FUNCTION_VB ID PARENTHESIS_A Parameters PARENTHESIS_B AS_VB Type {:sma.testManager.creatFatherAmbit();
                                                                                            sma.translateControlerTAC.createNewQuadrupleBlock();:}
                    |FUNCTION_VB ID PARENTHESIS_A Parameters PARENTHESIS_B AS_VB Type {:sma.testManager.creatFatherAmbit();
                                                                                        sma.translateControlerTAC.createNewQuadrupleBlock();:};
Sub_VB      ::= PUBLIC SUB_VB ID PARENTHESIS_A Parameters PARENTHESIS_B InstructionsFunctionVb END_VB SUB_VB; 
Parameters::= Parameter 
            |;
Parameter   ::= Parameter COMMA ID AS_VB Type{:System.out.println("PERAMENTE");:}
                | ID AS_VB Type;
InstructionsFunctionVb::= Lines LnInstructionsVb  
                            |Lines RETURN_VB ValuesVb
                            |Lines RETURN_VB
                            |LnInstructionsVb 
                            |RETURN_VB ValuesVb
                            |RETURN_VB;
Lines               ::=Lines LnInstructionsVb
                        |LnInstructionsVb;
LnInstructionsVb::= InputVb     
				|OutputVb 
				|CycleVb 
				|DeclarationVb  {:System.out.println("DECLARACION");:}
				|AssignmentVb   {:System.out.println("ASIGNACION");:}
                |ConditionVb  
				|error;
InputVb			::= INTINPUT PARENTHESIS_A STRING PARENTHESIS_B
					|FLOATINPUT PARENTHESIS_A STRING PARENTHESIS_B
					| CHARINPUT PARENTHESIS_A STRING PARENTHESIS_B ;
	
OutputVb		::=CONSOLE_VB POINT WRITE_VB PARENTHESIS_A ValuesVb PARENTHESIS_B{:System.out.println("OUTPUT LINE");:}
					|CONSOLE_VB POINT WRITELN_VB PARENTHESIS_A ValuesVb PARENTHESIS_B;
ValuesVb			::= ValueVb AMPERSON ValuesVb
				|ValueVb:val {:RESULT=val;
                                if(val!=null){System.out.println(((SynthesizedOpAsst)val).toString());}else{}System.out.println("NULL");
                                :};
ValueVb			::=STRING
				|NumberValue:val{:RESULT = val;:};

CycleVb         ::= ForVb
                    |WhileVb
                    |DoWhileVb;

ForVb           ::= FOR ID AS_VB Type EQUAL NumberValue TO_VB NumberValue Step InstructionsFunctionVb NEXT_VB 
                |FOR ID  EQUAL NumberValue TO_VB NumberValue Step InstructionsFunctionVb NEXT_VB;

Step            ::= STEP_VB NumberValue
                    | STEP_VB MINUS NumberValue
                    | STEP_VB PLUS NumberValue
                    |;
//NextVb          ::= NEXT_VB ID
  //                  | NEXT_VB;
                    
NumberValue::= NumberValue:num1 PLUS  Number2:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.PLUS);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                |NumberValue:num1 MINUS  Number2:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MINUS);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                |Number2:asst {:RESULT=asst;:};  
Number2     ::=Number2:num1 MULTIPLICATION  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MULTIPLICATION);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number2:num1 DIVISION  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.DIVISION);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number2:num1 MOD  Number3:num2 {:if(num1!=null &&num2!=null){ 
                                                               SynthesizedOpAsst s1= (SynthesizedOpAsst)num1;
                                                               SynthesizedOpAsst s2= (SynthesizedOpAsst)num2;
                                                                Type type=sma.testManager.operateType(s1.getType().getNumber(),s2.getType().getNumber(),((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                                if(type!=null){
                                                                    Quadruple quadruple=sma.translateControlerTAC.operateIdQuadruple(s1.getQuadruple(),s2.getQuadruple(),Operation.MOD);
                                                                    RESULT=new SynthesizedOpAsst(quadruple,type);
                                                                }else{
                                                                    RESULT=null;
                                                                }
                                                            }else{
                                                                RESULT=null;
                                                            }:}
                | Number3:asst {:RESULT=asst;:};
Number3     ::=NUMBER:val{: Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.INTEGER_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}

                |DECIMAL:val{:Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.FLOAT_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}
                |CHAR :val{:Type type =sma.testManager.getTypeManager().operateTypes(TypeManager.CHAR_TYPE,null);
                            Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
		                    RESULT=new SynthesizedOpAsst(quadruple,type);:}
                |ID:val {:Type type=sma.testManager.getTypeFromST(val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                            if(type!=null){
                                Quadruple quadruple=sma.translateControlerTAC.creatTempIdQuad(Operation.EQUAL,val,null,null);
                                RESULT=new SynthesizedOpAsst(quadruple,type);
                            }else{

                                RESULT=null;
                            }:}
                |PARENTHESIS_A NumberValue:asst PARENTHESIS_B {:RESULT=asst;:};
        
         

WhileVb         ::= WHILE  OpBool  InstructionsFunctionVb END_VB WHILE;

OpBool::= OpBool OpLogic BoolValueVb
       |BoolValueVb;
BoolValueVb       ::=NOT BoolValueVb
                    |NOT PARENTHESIS_A OpBool PARENTHESIS_B
                    //|ID 
                    |TRUE
                    |FALSE
                    |NumberValue ExBoolVb Number3;
OpLogic         ::= OR
                    |AND;
ExBoolVb          ::=EQUAL 
                    |DIFERENT_VB
                    |GREATER_THAN
                    |LESS_THAN                    
                    |GREATER_THAN_EQUAL
                    |LESS_THAN_EQUAL;

DoWhileVb       ::= DO  InstructionsFunctionVb LOOP_VB WHILE OpBool;

DeclarationVb     ::= DIM_VB DeTypeVb;
DeTypeVb        ::=  DeTypeVb COMMA  IdsVb AS_VB Type:type AssiVb {:sma.testManager.insertPreTuplesToSymbolTable((Integer)type,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()),sma.translateControlerTAC);:}
                    |IdsVb AS_VB Type:type AssiVb {:sma.testManager.insertPreTuplesToSymbolTable((Integer)type,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()),sma.translateControlerTAC);:};
Type          ::=INTEGER_TYPE{:RESULT=TypeManager.INTEGER_TYPE;:}
                    |FLOAT_TYPE {:RESULT=TypeManager.FLOAT_TYPE;:}
                    |CHAR_TYPE{:RESULT=TypeManager.CHAR_TYPE;:};                   

IdsVb           ::= IdsVb COMMA  ID:id AssiVb:val{:sma.testManager.insertPreTuple(id,null,val,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                        if(val!=null){ 
                                                            sma.translateControlerTAC.creatTempIdQuadAssign(val,id);}
                                                       
                                                        sma.translateControlerTAC.nextIdQuad();:}  
                    |ID:id AssiVb:val{:sma.testManager.insertPreTuple(id,null,val,null,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                        if(val!=null){ 
                                                            sma.translateControlerTAC.creatTempIdQuadAssign(val,id);}
                                        sma.translateControlerTAC.nextIdQuad();:}; 

AssiVb            ::= EQUAL ValueVb:val {:RESULT = val;:}
                    |{:System.out.println("ASSI VACIO");:};

AssignmentVb      ::=ID:id EQUAL ValueVb:val {:boolean bool= sma.testManager.assigValue(id,val,((Symbol) CUP$SyntaxMlgAnalyzer$stack.peek()));
                                                if(bool){sma.translateControlerTAC.creatTempIdQuadAssign(val,id);
                                                        sma.translateControlerTAC.acceptAllIdQuas()}:};

ConditionVb        ::= IfVb
                    |SwitchVb;

IfVb            ::= IF OpBool ThenVb InstructionsFunctionVb ElseVb END_VB IF;
ElseVb          ::= ELSE  InstructionsFunctionVb
                    | ELSE_IF_VB OpBool ThenVb InstructionsFunctionVb ElseVb
                    |; 
ThenVb          ::= THEN_VB
                    |;
SwitchVb        ::= SELECT_VB CASE_VB ID CasesVb END_VB SELECT_VB;
CasesVb         ::= CASE_VB ValueVb InstructionsFunctionVb CasesVb
                    |CASE_VB ELSE InstructionsFunctionVb;
/*
    JAVA
*/
Java 			::= JAVA_SEPERATOR JavaCode {:sma.testManager.switchNextTypes();:};

JavaCode::=JavaCode ClaseJ
            |;
ClaseJ  ::= ClaseJHeader LEFT_CB JavaClassCode RIGHT_CB;
ClaseJHeader::= PUBLIC CLASS_J ID {:sma.testManager.creatFatherAmbit();:};
ParametersJ::=ParametersJ COMMA Type ID
                | Type ID;
JavaClassCode::=JavaClassCode ClassCodeJ
                |ClassCodeJ;
ClassCodeJ  ::=FunctionJ
                |ProcessJ
                |LineCodeJ
                |ConstructorJ;
ConstructorJ ::=ConditionJHeader LEFT_CB LineCodesJ RIGHT_CB;
ConditionJHeader::=PUBLIC ID PARENTHESIS_A ParametersJ PARENTHESIS_B ;
FunctionJ       ::= FunctionJHeader  LEFT_CB LineCodesJ RIGHT_CB 
                    |FunctionJHeader  LEFT_CB  RIGHT_CB;
FunctionJHeader ::= PUBLIC Type ID PARENTHESIS_A ParametersJ PARENTHESIS_B
                    |PUBLIC Type ID PARENTHESIS_A PARENTHESIS_B;
ProcessJ        ::= ProcessJHeader LEFT_CB LineCodesJ RIGHT_CB
                    |ProcessJHeader LEFT_CB  RIGHT_CB;                 
ProcessJHeader  ::= PUBLIC VOID_J ID PARENTHESIS_A ParametersJ PARENTHESIS_B
                |PUBLIC VOID_J ID PARENTHESIS_A  PARENTHESIS_B;
LineCodesJ      ::=LineCodesJ2 RETURN_J ValuesJ
                    | LineCodesJ2;
LineCodesJ2      ::= LineCodesJ2 LineCodeJ
                |LineCodeJ;
ValuesJ         ::=StringValue
				|NumberValue;
StringValue     ::= StringValue PLUS STRING
                    |STRING;

ValuesOutputJ   ::=ValuesOutputJ PLUS ValJ
                    |ValJ;
                    
ValJ::=ID
                    |NUMBER
                    |DECIMAL
                    |STRING;

LineCodeJ   ::=OutputJ SEMICOLON
                |InputJ SEMICOLON
                |CycleJ
                |DeclarationJ SEMICOLON  {:System.out.println("DECLARACION");:}
				|AssignmentJ SEMICOLON  {:System.out.println("ASIGNACION");:}
                |ConditionJ 
                |error;
OutputJ     ::=SYSTEM_OUT_PRINTLN PARENTHESIS_A ValuesOutputJ PARENTHESIS_B
                |SYSTEM_OUT_PRINT PARENTHESIS_A ValuesOutputJ PARENTHESIS_B;

InputJ      ::= INTINPUT PARENTHESIS_A STRING PARENTHESIS_B
					|FLOATINPUT PARENTHESIS_A STRING PARENTHESIS_B
					| CHARINPUT PARENTHESIS_A STRING PARENTHESIS_B ;
CycleJ      ::=ForJHeader LEFT_CB LineCodesJ RIGHT_CB
                |WhileJHeader LEFT_CB LineCodesJ RIGHT_CB
                |DO LEFT_CB LineCodesJ RIGHT_CB WhileJHeader SEMICOLON;
ForJHeader        ::= FOR PARENTHESIS_A Type ID EQUAL NumberValue SEMICOLON ID ExBoolJ NumberValue SEMICOLON StepJ PARENTHESIS_B 
                    |FOR PARENTHESIS_A ID EQUAL NumberValue SEMICOLON ID ExBoolJ NumberValue SEMICOLON StepJ PARENTHESIS_B ;
WhileJHeader        ::= WHILE PARENTHESIS_A OpBoolJ PARENTHESIS_B; 
StepJ           ::= ID EQUAL NumberValue
                    |ID PLUS EQUAL NumberValue
                    |ID MINUS EQUAL NumberValue
                    |ID MULTIPLICATION EQUAL NumberValue
                    |ID DIVISION EQUAL NumberValue;   
DeclarationJ    ::=PUBLIC Type IdsVb{::}
                    |Type IdsVb{::};
AssignmentJ     ::= ID EQUAL ValueVb;

ConditionJ      ::= IfJ 
                    |SwitchJHeader LEFT_CB CasesJ1 RIGHT_CB;
IfJ             ::= IfJHeader LEFT_CB LineCodesJ RIGHT_CB ElseJ;
IfJHeader       ::= IF PARENTHESIS_A OpBoolJ PARENTHESIS_B;
ElseJ           ::= ELSE LEFT_CB LineCodesJ RIGHT_CB 
                    | ELSE IfJ
                    |;
SwitchJHeader   ::= SWITCH_J PARENTHESIS_A ID PARENTHESIS_B;
CasesJ1          ::=CasesJ2 CaseJ
                |CasesJ2 DEFAULT_J COLON LineCodesJ BreakJ
                |CaseJ;
CasesJ2         ::= CasesJ2 CaseJ
                    | CaseJ;
CaseJ           ::= CASE_J ValuesJ COLON LineCodesJ BreakJ;
BreakJ         ::= BREAK SEMICOLON
                    |;

ExBoolJ         ::=EQUAL EQUAL 
                    |DIFERENT_J
                    |GREATER_THAN
                    |LESS_THAN                    
                    |GREATER_THAN_EQUAL
                    |LESS_THAN_EQUAL;
BoolValueJ       ::=NOT BoolValueJ
                    |PARENTHESIS_A OpBoolJ PARENTHESIS_B
                    //|ID 
                    |TRUE
                    |FALSE
                    |NumberValue ExBoolJ NumberValue;
OpBoolJ::= OpBoolJ OpLogic BoolValueJ
        |BoolValueJ;
/*
    Python
*/
Python 	::= PYTHON_SEPERATOR PythonCode {:sma.testManager.switchNextTypes();:};
PythonCode::=;
/*
    C
*/

Programa ::=PROGRAM_SEPERATOR Library Constantes Globals Main ;
Library::= Library Include 
            | ;
Constantes ::= Constantes  Constante SEMICOLON
                |Constante SEMICOLON;
Constante::=CONST Type ID EQUAL ValueC
            |CONST Type ID Dimensions EQUAL ArrayValues;
Dimensions ::= Dimensions LEFT_BRACKET NumberValue RIGHT_BRACKET
                |LEFT_BRACKET NumberValue RIGHT_BRACKET;
ArrayValues ::= LEFT_CB Nums RIGHT_CB
                | LEFT_CB Rows RIGHT_CB;
Nums        ::= Nums COMMA NumberValue
                |NumberValue;
Rows        ::= Rows COMMA LEFT_CB Nums RIGHT_BRACKET
                |LEFT_CB Nums RIGHT_BRACKET;

Globals     ::=Globals  DeclarationC SEMICOLON
                |DeclarationC SEMICOLON;
Include ::= INCLUDE STRING 
            |INCLUDE LESS_THAN FuntionIDs GREATER_THAN;
Main::= VOID_J MAIN PARENTHESIS_A  PARENTHESIS_B LEFT_CB MainCode RIGHT_CB;

MainCode::= MainCode MainLineCode
            |MainLineCode;
MainLineCode ::= DeclarationC SEMICOLON
                |AssignmentC SEMICOLON
                |ConditionC
                |CycleC
                |OutputC SEMICOLON
                |Getch SEMICOLON
                |Input SEMICOLON
                |FuntionCall SEMICOLON;
DeclarationC  ::= Type IdsC;
IdsC           ::=ID AssiC COMMA IdsVb  
                    |ID AssiC; 
AssiC            ::= EQUAL ValueC
                    |Dimensions
                    |Dimensions EQUAL ArrayValues
                    |{:System.out.println("ASSI VACIO");:};

AssignmentC::= ID EQUAL ValueC
                |ID Dimensions EQUAL ValueC;
ConditionC  ::= IfCHeader LEFT_CB MainCode RIGHT_CB
                |SwitchCHeader  LEFT_CB CasesC RIGHT_CB;
IfCHeader::= IF PARENTHESIS_A OpBoolC PARENTHESIS_B;

SwitchCHeader::=SWITCH_J PARENTHESIS_A ID PARENTHESIS_B;
CasesC       ::=CasesC2 CaseC
                |CasesC2 DEFAULT_J COLON MainCode BreakJ
                |CaseC;
CasesC2     ::= CasesC2 CaseC
                |CaseC;
CaseC       ::= CASE_J COLON MainCode BreakJ;
CycleC      ::=ForCHeader LEFT_CB MainCode RIGHT_CB
                |WhileCHeader LEFT_CB MainCode RIGHT_CB
                |DO LEFT_CB MainCode RIGHT_CB WhileCHeader SEMICOLON;
ForCHeader        ::= FOR PARENTHESIS_A Type ID EQUAL ValueC SEMICOLON OpBoolC SEMICOLON StepC PARENTHESIS_B 
                    |FOR PARENTHESIS_A ID EQUAL ValueC SEMICOLON OpBoolC SEMICOLON StepC PARENTHESIS_B ;
WhileCHeader        ::= WHILE PARENTHESIS_A OpBoolC PARENTHESIS_B; 
StepC          ::= ID EQUAL ValueC
                    |ID PLUS EQUAL ValueC
                    |ID MINUS EQUAL ValueC
                    |ID MULTIPLICATION EQUAL ValueC
                    |ID DIVISION EQUAL ValueC;
OutputC         ::= PRINTF PARENTHESIS_A  OutputValuesC PARENTHESIS_B
                    |CLRSCR PARENTHESIS_A PARENTHESIS_B;
OutputValuesC   ::= OutputValuesC COMMA OutputValueC
                    |OutputValueC;
OutputValueC    ::= NUMBER
                    |ID
                    |DECIMAL
                    |STRING;

Getch ::=GETCH PARENTHESIS_A PARENTHESIS_B;
Input   ::= SCAN_F PARENTHESIS_A STRING COMMA AMPERSON ID PARENTHESIS_B ;
FuntionCall::=FuntionIDs PARENTHESIS_A ParametersC PARENTHESIS_B
                |FuntionIDs PARENTHESIS_A  PARENTHESIS_B;
FuntionIDs::= FuntionIDs POINT ID
            |ID;
ParametersC::=ParametersC COMMA ValueC 
            |ValueC;
ValueC::=STRING
        |NumberValue
        |FuntionCall
        |Getch
        |ArrayVal;

ArrayVal::= ID Dimensions;
BoolValueC       ::=NOT BoolValueC
                    |PARENTHESIS_A OpBoolJ PARENTHESIS_B
                    //|ID 
                    |FuntionCall
                    |TRUE
                    |FALSE
                    |NumberValue ExBoolJ NumberValue;
OpBoolC::= OpBoolC OpLogic BoolValueC
        |BoolValueC;



